import FlagBuilder

// create tasks for subprojects
subprojects { subproject ->
  // get right configuration for the subproject
  def config = rootProject.ext.configMap["$subproject.name"]

  task alignPalateTemplate {
    description = "Rigidly aligns the palate template using landmark information."

    def speaker = config.speaker.name
    def scan = config.speaker.scan
    def dataset = config.speaker.dataset

    // source and destination file
    def scanPath = config.speaker.scanPath

    // landmarks
    def landmarkFile = new File(rootProject.buildDir, "$scanPath/landmarksPalate/landmarks.json")
    def alignedTemplate = new File(rootProject.buildDir, "$scanPath/alignPalateTemplate/alignedTemplate.ply")

    // template file
    def templateFile  = new File(templateDir, "${palateTemplateName}.ply")

    // align depends on the landmarksPalate task
    dependsOn "landmarksPalate"

    inputs.file landmarkFile
    outputs.file alignedTemplate

    // read necessary settings


    doLast{
      alignedTemplate.getParentFile().mkdirs()

      logger.debug("landmark-alignment --noRotation --noScaling --source $templateFile --landmarks $landmarkFile --output $alignedTemplate")

      exec{
        commandLine "landmark-alignment --noRotation --noScaling --source $templateFile --landmarks $landmarkFile --output $alignedTemplate".tokenize()
        workingDir rootProject.buildDir
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////

  task landmarksPalate {

    description = "Computes palate landmarks files usable by the template matching."

    def speaker = config.speaker.name
    def scan = config.speaker.scan
    def dataset = config.speaker.dataset
    def scanPath = config.speaker.scanPath

    // source and destination directories
    def srcFile = file("$landmarksPalateDir/$scanPath/landmarks.json")
    def destFile = file("$rootProject.buildDir/$scanPath/landmarksPalate/landmarks.json")
    def templateLandmarksFile = file("$rootProject.buildDir/landmarksPalate.json")
    def scanFile = file("$mriDir/$scanPath/scan.json")

    // landmarksPalate depends on the createPalateTemplateLandmarks task
    dependsOn rootProject.createPalateTemplateLandmarks

    inputs.files srcFile, templateLandmarksFile, scanFile
    outputs.dir destFile

    doLast{

      destFile.parentFile.mkdirs()
      def slurper = new groovy.json.JsonSlurper()

      // open spacings of scan
      def spacings = slurper.parse(scanFile).spacings

      // open template landmarks
      def templateLandmarks = slurper.parse(templateLandmarksFile)

      // open user landmarks
      def userLandmarks = slurper.parse(srcFile)

      // construct landmark correspondences list
      def landmarks = []

      templateLandmarks.each{ mark ->
        def found = userLandmarks.find{
          it.name == mark.name
        }
        if ( found != null) {
          // fuse landmark information
          landmarks << [
            name: found.name,
            sourceIndex: mark.index,
            sourceX : mark.X,
            sourceY : mark.Y,
            sourceZ : mark.Z,
            // scale target positions according to the spacings
            targetX: found.x.toDouble() * spacings.x.toDouble(),
            targetY: found.y.toDouble() * spacings.y.toDouble(),
            targetZ: found.z.toDouble() * spacings.z.toDouble(),
          ]
        }
      }

      // build json file
      def json = new groovy.json.JsonBuilder(landmarks)

      destFile.withWriter{
        it << json.toPrettyString()
      }

    }
  }

  ///////////////////////////////////////////////////////////////////////////

  task matchPalate {
    description = "Performs template matching for extracting the palate shape."

    def speaker = config.speaker.name
    def scan = config.speaker.scan
    def dataset = config.speaker.dataset
    def scanPath = config.speaker.scanPath

    def pointCloud = file("$rootProject.buildDir/$scanPath/segmentPalate/point_cloud.obj")
    // landmarks, file does not need to exist
    def landmarkFile = file("$rootProject.buildDir/$scanPath/landmarksPalate/landmarks.json")
    def destDir = file("$rootProject.buildDir/$scanPath/matchPalate")

    // template file
    def templateFile = file("$rootProject.buildDir/$scanPath/alignPalateTemplate/alignedTemplate.ply")

    // matchPalate depends on the segmentPalate, landmarksPalate, and alignPalateTemplate task

    dependsOn "segmentPalate"
    dependsOn "landmarksPalate"
    dependsOn "alignPalateTemplate"

    inputs.file pointCloud
    outputs.dir destDir

    doLast{
      destDir.mkdirs()

      // assemble necessary settings
      def flags = (new FlagBuilder()).build(config.speaker.matchPalate)

      flags.add("--source $templateFile")
      flags.add("--target $pointCloud")
      flags.add("--output tracking_org_result0.ply")

      if( landmarkFile.exists() ) {
        flags.add("--landmarks $landmarkFile")
      }

      logger.debug("match-template ${flags.join(' ')}")

      exec{
        commandLine "match-template ${flags.join(' ')}".tokenize()
        workingDir destDir
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////


  task projectMatchedPalate { task ->
    description = "Projects matched palate to scan."

    def speaker = config.speaker.name
    def scan = config.speaker.scan
    def dataset = config.speaker.dataset
    def scanPath = config.speaker.scanPath

    // input
    def aligned = file("$rootProject.buildDir/$scanPath/matchPalate/tracking_org_result0.ply")
    def palateScan = file("$rootProject.buildDir/$scanPath/smooth/scan.json")

    // output
    def destDir = file("$rootProject.buildDir/$scanPath/$task.name")

    def projected = file("$destDir/projected.json")


    // projectPalate depends on the matchPalate task
    dependsOn "matchPalate"

    inputs.files aligned, palateScan
    outputs.dir destDir

    doLast{
     destDir.mkdirs()

      def command = "mesh-project --mesh $aligned --scan $palateScan --output $projected"
      logger.debug(command)
      exec{
        commandLine command.tokenize()
        workingDir rootProject.buildDir
      }
    }
  }

  ///////////////////////////////////////////////////////////////////////////

  task segmentPalate { task ->
    description = "Segments a smoothed scan by using thresholding. The normals in the point cloud are inverted."

    def speaker = config.speaker.name
    def scan = config.speaker.scan
    def dataset = config.speaker.dataset
    def scanPath = config.speaker.scanPath

    def srcFile = file("$rootProject.buildDir/$scanPath/smooth/scan.json")
    def destDir = file("$rootProject.buildDir/$scanPath/$task.name")
    def segmentation = file("$destDir/segmentation.json")
    def cloudFile = file("$destDir/point_cloud.obj")

    // segment depends on the smooth task
    def smooth = ":projects:shared:$dataset.name-$speaker-$scan:smooth"

    dependsOn smooth

    inputs.file srcFile
    outputs.dir destDir

    doLast{
      destDir.mkdirs()

      // read necessary settings
      def thresholdingType = config.speaker.segmentPalate.thresholdingType

      def command = ""

      if( thresholdingType == "BASIC" ) {

        def threshold = config.speaker.segmentPalate.threshold
        command = "threshold --source $srcFile --threshold $threshold --output $segmentation --cloud $cloudFile --flip"
      }
      else if( thresholdingType == "ADAPTIVE" ) {
        command = "adaptive-threshold --source $srcFile --output $segmentation --cloud $cloudFile --flip"
      }

      logger.debug(command)
      logging.captureStandardOutput LogLevel.DEBUG

      exec{
        commandLine command.tokenize()
        workingDir rootProject.buildDir
      }
    }
  }

}
